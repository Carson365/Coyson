{"ast":null,"code":"// Global variable to store books by category\nexport let booksByGenre = {};\n\n// Function to clean book data\nconst cleanBookData = (book, category) => {\n  return {\n    title: book.title || \"Unavailable\",\n    subtitle: book.subtitle || \"Unavailable\",\n    authors: book.authors && book.authors.length > 0 ? book.authors.join(\", \") : \"Unavailable\",\n    publisher: book.publisher || \"Unavailable\",\n    description: book.description || \"Unavailable\",\n    pageCount: book.pageCount || \"Unavailable\",\n    categories: category || \"Unavailable\",\n    // Set the category as provided\n    rating: book.averageRating || \"Unavailable\",\n    maturityRating: book.maturityRating || \"Unavailable\",\n    image: book.imageLinks ? book.imageLinks.thumbnail : \"Unavailable\"\n  };\n};\n\n// Fetch books by genre in batches\nexport const fetchBooksByGenre = async (genre, batchSize) => {\n  let booksFetched = 0;\n  let startIndex = 0;\n\n  // Ensure that the category exists in the booksByGenre object\n  if (!booksByGenre[genre]) {\n    booksByGenre[genre] = [];\n  }\n\n  // Loop to fetch books in batches\n  while (booksFetched < batchSize) {\n    const remainingBooks = batchSize - booksFetched;\n    const currentBatchSize = Math.min(remainingBooks, 40);\n    let response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=subject:${genre}&maxResults=${currentBatchSize}&startIndex=${startIndex}`);\n    let data = await response.json();\n    if (!data.items || data.items.length === 0) {\n      break;\n    }\n    data.items.forEach(item => {\n      const bookInfo = item.volumeInfo;\n      const cleanedBook = cleanBookData(bookInfo, genre);\n      booksByGenre[genre].push(cleanedBook);\n      booksFetched++;\n    });\n\n    // Move the startIndex forward for the next batch\n    startIndex += currentBatchSize;\n  }\n\n  // Log the result for debugging\n  console.log(booksByGenre);\n  return booksByGenre;\n};","map":{"version":3,"names":["booksByGenre","cleanBookData","book","category","title","subtitle","authors","length","join","publisher","description","pageCount","categories","rating","averageRating","maturityRating","image","imageLinks","thumbnail","fetchBooksByGenre","genre","batchSize","booksFetched","startIndex","remainingBooks","currentBatchSize","Math","min","response","fetch","data","json","items","forEach","item","bookInfo","volumeInfo","cleanedBook","push","console","log"],"sources":["/Users/coycrowder/MIS 321/react/my-app/src/Api.js"],"sourcesContent":["// Global variable to store books by category\nexport let booksByGenre = {};\n\n// Function to clean book data\nconst cleanBookData = (book, category) => {\n  return {\n    title: book.title || \"Unavailable\",\n    subtitle: book.subtitle || \"Unavailable\",\n    authors: (book.authors && book.authors.length > 0) ? book.authors.join(\", \") : \"Unavailable\",\n    publisher: book.publisher || \"Unavailable\",\n    description: book.description || \"Unavailable\",\n    pageCount: book.pageCount || \"Unavailable\",\n    categories: category || \"Unavailable\", // Set the category as provided\n    rating: book.averageRating || \"Unavailable\",\n    maturityRating: book.maturityRating || \"Unavailable\",\n    image: book.imageLinks ? book.imageLinks.thumbnail : \"Unavailable\",\n  };\n};\n\n// Fetch books by genre in batches\nexport const fetchBooksByGenre = async (genre, batchSize) => {\n  let booksFetched = 0;\n  let startIndex = 0;\n\n  // Ensure that the category exists in the booksByGenre object\n  if (!booksByGenre[genre]) {\n    booksByGenre[genre] = [];\n  }\n\n  // Loop to fetch books in batches\n  while (booksFetched < batchSize) {\n    const remainingBooks = batchSize - booksFetched;\n    const currentBatchSize = Math.min(remainingBooks, 40);\n\n    let response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=subject:${genre}&maxResults=${currentBatchSize}&startIndex=${startIndex}`);\n    let data = await response.json();\n\n    if (!data.items || data.items.length === 0) {\n      break;\n    }\n\n    data.items.forEach(item => {\n      const bookInfo = item.volumeInfo;\n      const cleanedBook = cleanBookData(bookInfo, genre);\n      booksByGenre[genre].push(cleanedBook);\n      booksFetched++;\n    });\n\n    // Move the startIndex forward for the next batch\n    startIndex += currentBatchSize;\n  }\n\n  // Log the result for debugging\n  console.log(booksByGenre);\n  return booksByGenre;\n};"],"mappings":"AAAA;AACA,OAAO,IAAIA,YAAY,GAAG,CAAC,CAAC;;AAE5B;AACA,MAAMC,aAAa,GAAGA,CAACC,IAAI,EAAEC,QAAQ,KAAK;EACxC,OAAO;IACLC,KAAK,EAAEF,IAAI,CAACE,KAAK,IAAI,aAAa;IAClCC,QAAQ,EAAEH,IAAI,CAACG,QAAQ,IAAI,aAAa;IACxCC,OAAO,EAAGJ,IAAI,CAACI,OAAO,IAAIJ,IAAI,CAACI,OAAO,CAACC,MAAM,GAAG,CAAC,GAAIL,IAAI,CAACI,OAAO,CAACE,IAAI,CAAC,IAAI,CAAC,GAAG,aAAa;IAC5FC,SAAS,EAAEP,IAAI,CAACO,SAAS,IAAI,aAAa;IAC1CC,WAAW,EAAER,IAAI,CAACQ,WAAW,IAAI,aAAa;IAC9CC,SAAS,EAAET,IAAI,CAACS,SAAS,IAAI,aAAa;IAC1CC,UAAU,EAAET,QAAQ,IAAI,aAAa;IAAE;IACvCU,MAAM,EAAEX,IAAI,CAACY,aAAa,IAAI,aAAa;IAC3CC,cAAc,EAAEb,IAAI,CAACa,cAAc,IAAI,aAAa;IACpDC,KAAK,EAAEd,IAAI,CAACe,UAAU,GAAGf,IAAI,CAACe,UAAU,CAACC,SAAS,GAAG;EACvD,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMC,iBAAiB,GAAG,MAAAA,CAAOC,KAAK,EAAEC,SAAS,KAAK;EAC3D,IAAIC,YAAY,GAAG,CAAC;EACpB,IAAIC,UAAU,GAAG,CAAC;;EAElB;EACA,IAAI,CAACvB,YAAY,CAACoB,KAAK,CAAC,EAAE;IACxBpB,YAAY,CAACoB,KAAK,CAAC,GAAG,EAAE;EAC1B;;EAEA;EACA,OAAOE,YAAY,GAAGD,SAAS,EAAE;IAC/B,MAAMG,cAAc,GAAGH,SAAS,GAAGC,YAAY;IAC/C,MAAMG,gBAAgB,GAAGC,IAAI,CAACC,GAAG,CAACH,cAAc,EAAE,EAAE,CAAC;IAErD,IAAII,QAAQ,GAAG,MAAMC,KAAK,CAAC,yDAAyDT,KAAK,eAAeK,gBAAgB,eAAeF,UAAU,EAAE,CAAC;IACpJ,IAAIO,IAAI,GAAG,MAAMF,QAAQ,CAACG,IAAI,CAAC,CAAC;IAEhC,IAAI,CAACD,IAAI,CAACE,KAAK,IAAIF,IAAI,CAACE,KAAK,CAACzB,MAAM,KAAK,CAAC,EAAE;MAC1C;IACF;IAEAuB,IAAI,CAACE,KAAK,CAACC,OAAO,CAACC,IAAI,IAAI;MACzB,MAAMC,QAAQ,GAAGD,IAAI,CAACE,UAAU;MAChC,MAAMC,WAAW,GAAGpC,aAAa,CAACkC,QAAQ,EAAEf,KAAK,CAAC;MAClDpB,YAAY,CAACoB,KAAK,CAAC,CAACkB,IAAI,CAACD,WAAW,CAAC;MACrCf,YAAY,EAAE;IAChB,CAAC,CAAC;;IAEF;IACAC,UAAU,IAAIE,gBAAgB;EAChC;;EAEA;EACAc,OAAO,CAACC,GAAG,CAACxC,YAAY,CAAC;EACzB,OAAOA,YAAY;AACrB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}