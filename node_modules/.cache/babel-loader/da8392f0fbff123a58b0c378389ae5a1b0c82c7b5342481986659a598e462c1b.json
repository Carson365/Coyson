{"ast":null,"code":"export let booksByGenre = {};\nexport const allGenres = [\"Fiction\", \"Mystery\", \"Biography\", \"Fantasy\", \"AutoBiography\", \"Nonfiction\", \"Thriller\", \"Science Fiction\", \"Poetry\", \"Novel\"];\nexport const genreIDs = [{\n  id: crypto.randomUUID(),\n  genre: \"Fiction\"\n}, {\n  id: crypto.randomUUID(),\n  genre: \"Mystery\"\n}, {\n  id: crypto.randomUUID(),\n  genre: \"Biography\"\n}, {\n  id: crypto.randomUUID(),\n  genre: \"Fantasy\"\n}, {\n  id: crypto.randomUUID(),\n  genre: \"AutoBiography\"\n}, {\n  id: crypto.randomUUID(),\n  genre: \"Nonfiction\"\n}, {\n  id: crypto.randomUUID(),\n  genre: \"Thriller\"\n}, {\n  id: crypto.randomUUID(),\n  genre: \"Science Fiction\"\n}, {\n  id: crypto.randomUUID(),\n  genre: \"Poetry\"\n}, {\n  id: crypto.randomUUID(),\n  genre: \"Novel\"\n}];\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\nexport const fetchAllGenres = async () => {\n  for (const genre of allGenres) {\n    await fetchBooksByGenre(genre, 64);\n    await delay(200);\n  }\n  console.log(booksByGenre);\n};\nconst cleanBookData = (book, category) => {\n  var _book$imageLinks;\n  // Find genre ID based on category[0]\n  const genre = category[0];\n  const genreData = genreIDs.find(g => g.genre === genre);\n  return {\n    id: crypto.randomUUID(),\n    genreid: genreData ? genreData.id : null,\n    // Assign the found genre ID or null if not found\n    title: (book === null || book === void 0 ? void 0 : book.title) || \"Unavailable\",\n    subtitle: (book === null || book === void 0 ? void 0 : book.subtitle) || \"Unavailable\",\n    authors: Array.isArray(book === null || book === void 0 ? void 0 : book.authors) ? book.authors : [],\n    publisher: (book === null || book === void 0 ? void 0 : book.publisher) || \"Unavailable\",\n    description: (book === null || book === void 0 ? void 0 : book.description) || \"Unavailable\",\n    pageCount: (book === null || book === void 0 ? void 0 : book.pageCount) || \"Unavailable\",\n    categories: category || \"Unavailable\",\n    rating: (book === null || book === void 0 ? void 0 : book.averageRating) || \"Unavailable\",\n    maturityRating: (book === null || book === void 0 ? void 0 : book.maturityRating) || \"Unavailable\",\n    image: (book === null || book === void 0 ? void 0 : (_book$imageLinks = book.imageLinks) === null || _book$imageLinks === void 0 ? void 0 : _book$imageLinks.thumbnail) || null\n  };\n};\nconst isDuplicateBook = (book, genre) => {\n  return booksByGenre[genre].some(existingBook => existingBook.title === book.title);\n};\nexport const fetchBooksByGenre = async (genre, batchSize) => {\n  let booksFetched = 0;\n  let startIndex = 0;\n  if (!booksByGenre[genre]) {\n    booksByGenre[genre] = [];\n  }\n  while (booksFetched < batchSize) {\n    const remainingBooks = batchSize - booksFetched;\n    const currentBatchSize = Math.min(remainingBooks, 40);\n    try {\n      const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=subject:${genre}&maxResults=${currentBatchSize}&startIndex=${startIndex}`);\n      const data = await response.json();\n      if (!data.items || data.items.length === 0) break;\n      data.items.forEach(item => {\n        if (!item.volumeInfo) return;\n        const cleanedBook = cleanBookData(item.volumeInfo, genre);\n        if (!isDuplicateBook(cleanedBook, genre) && cleanedBook.image) {\n          booksByGenre[genre].push(cleanedBook);\n          booksFetched++;\n        }\n      });\n      startIndex += currentBatchSize;\n    } catch (error) {\n      console.error(`Error fetching books for genre \"${genre}\":`, error);\n      break;\n    }\n  }\n  console.log(`Loaded ${genre}:`);\n  return booksByGenre[genre];\n};","map":{"version":3,"names":["booksByGenre","allGenres","genreIDs","id","crypto","randomUUID","genre","delay","ms","Promise","resolve","setTimeout","fetchAllGenres","fetchBooksByGenre","console","log","cleanBookData","book","category","_book$imageLinks","genreData","find","g","genreid","title","subtitle","authors","Array","isArray","publisher","description","pageCount","categories","rating","averageRating","maturityRating","image","imageLinks","thumbnail","isDuplicateBook","some","existingBook","batchSize","booksFetched","startIndex","remainingBooks","currentBatchSize","Math","min","response","fetch","data","json","items","length","forEach","item","volumeInfo","cleanedBook","push","error"],"sources":["/Users/coycrowder/MIS 321/321Project/Coyson/src/Api.js"],"sourcesContent":["export let booksByGenre = {};\n\nexport const allGenres = [\n  \"Fiction\",\n  \"Mystery\",\n  \"Biography\",\n  \"Fantasy\",\n  \"AutoBiography\",\n  \"Nonfiction\",\n  \"Thriller\",\n  \"Science Fiction\",\n  \"Poetry\",\n  \"Novel\"\n];\n\nexport const genreIDs = [\n  { id: crypto.randomUUID(), genre: \"Fiction\" },\n  { id: crypto.randomUUID(), genre: \"Mystery\" },\n  { id: crypto.randomUUID(), genre: \"Biography\" },\n  { id: crypto.randomUUID(), genre: \"Fantasy\" },\n  { id: crypto.randomUUID(), genre: \"AutoBiography\" },\n  { id: crypto.randomUUID(), genre: \"Nonfiction\" },\n  { id: crypto.randomUUID(), genre: \"Thriller\" },\n  { id: crypto.randomUUID(), genre: \"Science Fiction\" },\n  { id: crypto.randomUUID(), genre: \"Poetry\" },\n  { id: crypto.randomUUID(), genre: \"Novel\" }\n];\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nexport const fetchAllGenres = async () => {\n  for (const genre of allGenres) {\n    await fetchBooksByGenre(genre, 64);\n    await delay(200);\n  }\n  console.log(booksByGenre);\n};\n\nconst cleanBookData = (book, category) => {\n  // Find genre ID based on category[0]\n  const genre = category[0];\n  const genreData = genreIDs.find(g => g.genre === genre);\n\n  return {\n    id: crypto.randomUUID(),\n    genreid: genreData ? genreData.id : null, // Assign the found genre ID or null if not found\n    title: book?.title || \"Unavailable\",\n    subtitle: book?.subtitle || \"Unavailable\",\n    authors: Array.isArray(book?.authors) ? book.authors : [],\n    publisher: book?.publisher || \"Unavailable\",\n    description: book?.description || \"Unavailable\",\n    pageCount: book?.pageCount || \"Unavailable\",\n    categories: category || \"Unavailable\", \n    rating: book?.averageRating || \"Unavailable\",\n    maturityRating: book?.maturityRating || \"Unavailable\",\n    image: book?.imageLinks?.thumbnail || null,\n  };\n};\n\nconst isDuplicateBook = (book, genre) => {\n  return booksByGenre[genre].some(existingBook => existingBook.title === book.title);\n};\n\nexport const fetchBooksByGenre = async (genre, batchSize) => {\n  let booksFetched = 0;\n  let startIndex = 0;\n\n  if (!booksByGenre[genre]) {\n    booksByGenre[genre] = [];\n  }\n\n  while (booksFetched < batchSize) {\n    const remainingBooks = batchSize - booksFetched;\n    const currentBatchSize = Math.min(remainingBooks, 40);\n\n    try {\n      const response = await fetch(\n        `https://www.googleapis.com/books/v1/volumes?q=subject:${genre}&maxResults=${currentBatchSize}&startIndex=${startIndex}`\n      );\n\n      const data = await response.json();\n\n      if (!data.items || data.items.length === 0) break;\n\n      data.items.forEach(item => {\n        if (!item.volumeInfo) return;\n\n        const cleanedBook = cleanBookData(item.volumeInfo, genre);\n\n        if (!isDuplicateBook(cleanedBook, genre) && cleanedBook.image) {\n          booksByGenre[genre].push(cleanedBook);\n          booksFetched++;\n        }\n      });\n\n      startIndex += currentBatchSize;\n    } catch (error) {\n      console.error(`Error fetching books for genre \"${genre}\":`, error);\n      break;\n    }\n  }\n\n  console.log(`Loaded ${genre}:`);\n\n  return booksByGenre[genre];\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}