{"ast":null,"code":"export let booksByGenre = {};\nexport const allGenres = [\"Fiction\", \"Mystery\", \"Biography\", \"Fantasy\", \"AutoBiography\", \"Nonfiction\", \"Thriller\", \"Science Fiction\", \"Poetry\", \"Novel\"];\nexport const genreIDs = [{\n  id: 101,\n  genre: \"Fiction\"\n}, {\n  id: 102,\n  genre: \"Mystery\"\n}, {\n  id: 103,\n  genre: \"Biography\"\n}, {\n  id: 104,\n  genre: \"Fantasy\"\n}, {\n  id: 105,\n  genre: \"AutoBiography\"\n}, {\n  id: 106,\n  genre: \"Nonfiction\"\n}, {\n  id: 107,\n  genre: \"Thriller\"\n}, {\n  id: 108,\n  genre: \"Science Fiction\"\n}, {\n  id: 109,\n  genre: \"Poetry\"\n}, {\n  id: 110,\n  genre: \"Novel\"\n}];\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\nexport const fetchAllGenres = async () => {\n  for (const genre of allGenres) {\n    await fetchBooksByGenre(genre, 64);\n    await delay(200);\n  }\n  console.log(booksByGenre);\n};\nconst cleanBookData = (book, matchedGenres) => {\n  var _genreIDs$find$id, _genreIDs$find, _book$title, _book$subtitle, _book$publisher, _book$description, _book$pageCount, _book$averageRating, _book$maturityRating, _book$imageLinks$thum, _book$imageLinks;\n  const genreid = (_genreIDs$find$id = (_genreIDs$find = genreIDs.find(g => g.genre === matchedGenres[0])) === null || _genreIDs$find === void 0 ? void 0 : _genreIDs$find.id) !== null && _genreIDs$find$id !== void 0 ? _genreIDs$find$id : null;\n  return {\n    id: crypto.randomUUID(),\n    genreid,\n    title: (_book$title = book === null || book === void 0 ? void 0 : book.title) !== null && _book$title !== void 0 ? _book$title : \"Unavailable\",\n    subtitle: (_book$subtitle = book === null || book === void 0 ? void 0 : book.subtitle) !== null && _book$subtitle !== void 0 ? _book$subtitle : \"Unavailable\",\n    authors: Array.isArray(book === null || book === void 0 ? void 0 : book.authors) ? book.authors : [],\n    publisher: (_book$publisher = book === null || book === void 0 ? void 0 : book.publisher) !== null && _book$publisher !== void 0 ? _book$publisher : \"Unavailable\",\n    description: (_book$description = book === null || book === void 0 ? void 0 : book.description) !== null && _book$description !== void 0 ? _book$description : \"Unavailable\",\n    pageCount: (_book$pageCount = book === null || book === void 0 ? void 0 : book.pageCount) !== null && _book$pageCount !== void 0 ? _book$pageCount : \"Unavailable\",\n    categories: matchedGenres,\n    rating: (_book$averageRating = book === null || book === void 0 ? void 0 : book.averageRating) !== null && _book$averageRating !== void 0 ? _book$averageRating : \"Unavailable\",\n    maturityRating: (_book$maturityRating = book === null || book === void 0 ? void 0 : book.maturityRating) !== null && _book$maturityRating !== void 0 ? _book$maturityRating : \"Unavailable\",\n    image: (_book$imageLinks$thum = book === null || book === void 0 ? void 0 : (_book$imageLinks = book.imageLinks) === null || _book$imageLinks === void 0 ? void 0 : _book$imageLinks.thumbnail) !== null && _book$imageLinks$thum !== void 0 ? _book$imageLinks$thum : null\n  };\n};\nconst isDuplicateBook = (book, genre) => {\n  var _booksByGenre$genre$s, _booksByGenre$genre;\n  return (_booksByGenre$genre$s = (_booksByGenre$genre = booksByGenre[genre]) === null || _booksByGenre$genre === void 0 ? void 0 : _booksByGenre$genre.some(existingBook => existingBook.title === book.title)) !== null && _booksByGenre$genre$s !== void 0 ? _booksByGenre$genre$s : false;\n};\nexport const fetchBooksByGenre = async (genre, batchSize) => {\n  let booksFetched = 0;\n  let startIndex = 0;\n  while (booksFetched < batchSize) {\n    const remainingBooks = batchSize - booksFetched;\n    const currentBatchSize = Math.min(remainingBooks, 40);\n    try {\n      const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=subject:${genre}&maxResults=${currentBatchSize}&startIndex=${startIndex}`);\n      const data = await response.json();\n      if (!data.items || data.items.length === 0) break;\n      data.items.forEach(item => {\n        var _info$imageLinks;\n        const info = item.volumeInfo;\n        if (!info || !((_info$imageLinks = info.imageLinks) !== null && _info$imageLinks !== void 0 && _info$imageLinks.thumbnail)) return;\n        const forcedGenre = [genre];\n        const cleanedBook = cleanBookData(info, forcedGenre);\n        if (!booksByGenre[genre]) {\n          booksByGenre[genre] = [];\n        }\n        if (!isDuplicateBook(cleanedBook, genre)) {\n          booksByGenre[genre].push(cleanedBook);\n          booksFetched++;\n        }\n      });\n      startIndex += currentBatchSize;\n    } catch (error) {\n      console.error(`Error fetching books for genre \"${genre}\":`, error);\n      break;\n    }\n  }\n  return booksByGenre;\n};","map":{"version":3,"names":["booksByGenre","allGenres","genreIDs","id","genre","delay","ms","Promise","resolve","setTimeout","fetchAllGenres","fetchBooksByGenre","console","log","cleanBookData","book","matchedGenres","_genreIDs$find$id","_genreIDs$find","_book$title","_book$subtitle","_book$publisher","_book$description","_book$pageCount","_book$averageRating","_book$maturityRating","_book$imageLinks$thum","_book$imageLinks","genreid","find","g","crypto","randomUUID","title","subtitle","authors","Array","isArray","publisher","description","pageCount","categories","rating","averageRating","maturityRating","image","imageLinks","thumbnail","isDuplicateBook","_booksByGenre$genre$s","_booksByGenre$genre","some","existingBook","batchSize","booksFetched","startIndex","remainingBooks","currentBatchSize","Math","min","response","fetch","data","json","items","length","forEach","item","_info$imageLinks","info","volumeInfo","forcedGenre","cleanedBook","push","error"],"sources":["C:/Users/carso/Documents/Code/321/Coyson/src/Api.js"],"sourcesContent":["export let booksByGenre = {};\r\n\r\nexport const allGenres = [\r\n  \"Fiction\",\r\n  \"Mystery\",\r\n  \"Biography\",\r\n  \"Fantasy\",\r\n  \"AutoBiography\",\r\n  \"Nonfiction\",\r\n  \"Thriller\",\r\n  \"Science Fiction\",\r\n  \"Poetry\",\r\n  \"Novel\"\r\n];\r\n\r\nexport const genreIDs = [\r\n  { id: 101, genre: \"Fiction\" },\r\n  { id: 102, genre: \"Mystery\" },\r\n  { id: 103, genre: \"Biography\" },\r\n  { id: 104, genre: \"Fantasy\" },\r\n  { id: 105, genre: \"AutoBiography\" },\r\n  { id: 106, genre: \"Nonfiction\" },\r\n  { id: 107, genre: \"Thriller\" },\r\n  { id: 108, genre: \"Science Fiction\" },\r\n  { id: 109, genre: \"Poetry\" },\r\n  { id: 110, genre: \"Novel\" }\r\n];\r\n\r\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\nexport const fetchAllGenres = async () => {\r\n  for (const genre of allGenres) {\r\n    await fetchBooksByGenre(genre, 64);\r\n    await delay(200);\r\n  }\r\n  console.log(booksByGenre);\r\n};\r\n\r\nconst cleanBookData = (book, matchedGenres) => {\r\n  const genreid = genreIDs.find(g => g.genre === matchedGenres[0])?.id ?? null;\r\n\r\n  return {\r\n    id: crypto.randomUUID(),\r\n    genreid,\r\n    title: book?.title ?? \"Unavailable\",\r\n    subtitle: book?.subtitle ?? \"Unavailable\",\r\n    authors: Array.isArray(book?.authors) ? book.authors : [],\r\n    publisher: book?.publisher ?? \"Unavailable\",\r\n    description: book?.description ?? \"Unavailable\",\r\n    pageCount: book?.pageCount ?? \"Unavailable\",\r\n    categories: matchedGenres, \r\n    rating: book?.averageRating ?? \"Unavailable\",\r\n    maturityRating: book?.maturityRating ?? \"Unavailable\",\r\n    image: book?.imageLinks?.thumbnail ?? null\r\n  };\r\n};\r\n\r\nconst isDuplicateBook = (book, genre) => {\r\n  return booksByGenre[genre]?.some(existingBook => existingBook.title === book.title) ?? false;\r\n};\r\n\r\nexport const fetchBooksByGenre = async (genre, batchSize) => {\r\n  let booksFetched = 0;\r\n  let startIndex = 0;\r\n\r\n  while (booksFetched < batchSize) {\r\n    const remainingBooks = batchSize - booksFetched;\r\n    const currentBatchSize = Math.min(remainingBooks, 40);\r\n\r\n    try {\r\n      const response = await fetch(\r\n        `https://www.googleapis.com/books/v1/volumes?q=subject:${genre}&maxResults=${currentBatchSize}&startIndex=${startIndex}`\r\n      );\r\n\r\n      const data = await response.json();\r\n      if (!data.items || data.items.length === 0) break;\r\n\r\n      data.items.forEach(item => {\r\n        const info = item.volumeInfo;\r\n        if (!info || !info.imageLinks?.thumbnail) return;\r\n\r\n        const forcedGenre = [genre];\r\n\r\n        const cleanedBook = cleanBookData(info, forcedGenre);\r\n\r\n        if (!booksByGenre[genre]) {\r\n          booksByGenre[genre] = [];\r\n        }\r\n\r\n        if (!isDuplicateBook(cleanedBook, genre)) {\r\n          booksByGenre[genre].push(cleanedBook);\r\n          booksFetched++;\r\n        }\r\n      });\r\n\r\n      startIndex += currentBatchSize;\r\n    } catch (error) {\r\n      console.error(`Error fetching books for genre \"${genre}\":`, error);\r\n      break;\r\n    }\r\n  }\r\n\r\n  return booksByGenre;\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}