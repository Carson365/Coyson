{"ast":null,"code":"import { GetBookByID } from \"./BookData\";\n\n// Add Price\nlet count = 0;\nexport let booksByGenre = {};\nexport const allGenres = [\"Fiction\", \"Mystery\", \"Biography\", \"Fantasy\", \"AutoBiography\", \"Nonfiction\", \"Thriller\", \"Science Fiction\", \"Poetry\", \"Novel\"];\nexport const genreIDs = [{\n  id: 101,\n  genre: \"Fiction\"\n}, {\n  id: 102,\n  genre: \"Mystery\"\n}, {\n  id: 103,\n  genre: \"Biography\"\n}, {\n  id: 104,\n  genre: \"Fantasy\"\n}, {\n  id: 105,\n  genre: \"AutoBiography\"\n}, {\n  id: 106,\n  genre: \"Nonfiction\"\n}, {\n  id: 107,\n  genre: \"Thriller\"\n}, {\n  id: 108,\n  genre: \"Science Fiction\"\n}, {\n  id: 109,\n  genre: \"Poetry\"\n}, {\n  id: 110,\n  genre: \"Novel\"\n}];\nexport function AddBookToDB(book) {\n  fetch('http://localhost:5000/api/Book', {\n    method: 'POST',\n    headers: {\n      'accept': 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      genreID: book.genreid,\n      title: book.title,\n      subtitle: book.subtitle,\n      authors: book.authors,\n      publisher: book.publisher,\n      description: book.description,\n      pageCount: book.pageCount,\n      categories: book.categories,\n      rating: book.rating,\n      maturityRating: book.maturityRating,\n      image: book.image,\n      price: book.price\n    })\n  }).then(response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    return response.text();\n  }).then(data => {\n    console.log(\"Success:\", data);\n  }).catch(error => {\n    console.error(\"Error:\", error);\n  });\n}\n_c = AddBookToDB;\nexport const GetBookByGenre = async genreID => {\n  const response = await fetch(`http://localhost:5000/api/book/genre/${genreID}`);\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  const books = await response.json();\n  if (!booksByGenre[genreID]) {\n    booksByGenre[genreID] = [];\n  }\n  books.forEach(book => {\n    booksByGenre[genreID].push(book);\n  });\n  console.log(booksByGenre);\n};\n\n/*  All Commented Below is for fetching books from Google API\n\nconst getRandomPrice = () => {\n  const prices = [19.99, 24.99, 29.99, 34.99, 39.99];\n  const randomIndex = Math.floor(Math.random() * prices.length);\n  return prices[randomIndex];\n};\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nexport const fetchAllGenres = async () => {\n  for (const genre of allGenres) {\n    await fetchBooksByGenre(genre, 64);\n    await delay(200);\n  }\n  console.log(booksByGenre);\n};\n\nconst cleanBookData = (book, matchedGenres) => {\n  const genreid = genreIDs.find(g => g.genre === matchedGenres[0])?.id ?? null;\n  count++;\n\n  return {\n    genreid: typeof genreid === \"number\" ? genreid : null,\n    title: book?.title ?? \"Unavailable\",\n    subtitle: book?.subtitle ?? null,\n    authors: Array.isArray(book?.authors) \n      ? (book.authors[0] ?? \"Unavailable\") \n      : (book?.authors ?? \"Unavailable\"),\n    publisher: book?.publisher ?? null,\n    description: book?.description ?? null,\n    pageCount: typeof book?.pageCount === \"number\" ? book.pageCount : null,\n    categories: Array.isArray(matchedGenres) \n      ? (matchedGenres[0] ?? null) \n      : (matchedGenres ?? null),\n    rating: typeof book?.averageRating === \"number\" ? book.averageRating : null,\n    maturityRating: book?.maturityRating ?? null,\n    image: book?.imageLinks?.thumbnail ?? null,\n    price: getRandomPrice()\n  }  \n};\n\n\nconst isDuplicateBook = (book, genre) => {\n  return booksByGenre[genre]?.some(existingBook => existingBook.title === book.title) ?? false;\n};\n\n\nexport const fetchBooksByGenre = async (genre, batchSize) => {\n  let booksFetched = 0;\n  let startIndex = 0;\n\n  \n  while (booksFetched < batchSize) {\n    const remainingBooks = batchSize - booksFetched;\n    const currentBatchSize = Math.min(remainingBooks, 40);\n\n    try {\n      const response = await fetch(\n        `https://www.googleapis.com/books/v1/volumes?q=subject:${genre}&maxResults=${currentBatchSize}&startIndex=${startIndex}`\n      );\n\n      const data = await response.json();\n\n      if (!data.items || data.items.length === 0) break;\n\n      for (const item of data.items) {\n        const info = item.volumeInfo;\n        if (!info || !info.imageLinks?.thumbnail) continue;\n\n        const forcedGenre = [genre];\n        const cleanedBook = cleanBookData(info, forcedGenre);\n\n        if (!booksByGenre[genre]) {\n          booksByGenre[genre] = [];\n        }\n\n        if (!isDuplicateBook(cleanedBook, genre)) {\n          booksByGenre[genre].push(cleanedBook);\n          booksFetched++;\n        }\n\n        if (booksFetched >= batchSize) break; \n      }\n\n      startIndex += currentBatchSize;\n    } catch (error) {\n      console.error(`Error fetching books for genre \"${genre}\":`, error);\n      break;\n    }\n  }\n  await delay(500);\n  console.log(booksByGenre)\n  \n  return booksByGenre;\n};\n*/\n_c2 = GetBookByGenre;\nvar _c, _c2;\n$RefreshReg$(_c, \"AddBookToDB\");\n$RefreshReg$(_c2, \"GetBookByGenre\");","map":{"version":3,"names":["GetBookByID","count","booksByGenre","allGenres","genreIDs","id","genre","AddBookToDB","book","fetch","method","headers","body","JSON","stringify","genreID","genreid","title","subtitle","authors","publisher","description","pageCount","categories","rating","maturityRating","image","price","then","response","ok","Error","status","text","data","console","log","catch","error","_c","GetBookByGenre","books","json","forEach","push","_c2","$RefreshReg$"],"sources":["/Users/coycrowder/MIS 321/321Project/Coyson/src/Api.js"],"sourcesContent":["import { GetBookByID } from \"./BookData\";\n\n// Add Price\nlet count = 0;\n\nexport let booksByGenre = {};\n\nexport const allGenres = [\n  \"Fiction\",\n  \"Mystery\",\n  \"Biography\",\n  \"Fantasy\",\n  \"AutoBiography\",\n  \"Nonfiction\",\n  \"Thriller\",\n  \"Science Fiction\",\n  \"Poetry\",\n  \"Novel\"\n];\n\nexport const genreIDs = [\n  { id: 101, genre: \"Fiction\" },\n  { id: 102, genre: \"Mystery\" },\n  { id: 103, genre: \"Biography\" },\n  { id: 104, genre: \"Fantasy\" },\n  { id: 105, genre: \"AutoBiography\" },\n  { id: 106, genre: \"Nonfiction\" },\n  { id: 107, genre: \"Thriller\" },\n  { id: 108, genre: \"Science Fiction\" },\n  { id: 109, genre: \"Poetry\" },\n  { id: 110, genre: \"Novel\" }\n];\n\nexport function AddBookToDB(book){\n  fetch('http://localhost:5000/api/Book', {\n    method: 'POST',\n    headers: {\n      'accept': 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      genreID: book.genreid,\n      title: book.title,\n      subtitle: book.subtitle,\n      authors: book.authors,\n      publisher: book.publisher,\n      description: book.description,\n      pageCount: book.pageCount,\n      categories: book.categories,\n      rating: book.rating,\n      maturityRating: book.maturityRating,\n      image: book.image,\n      price: book.price,\n    })\n  })\n  .then(response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    return response.text();\n  })\n  .then(data => {\n    console.log(\"Success:\", data);\n  })\n  .catch(error => {\n    console.error(\"Error:\", error);\n  });\n}\n\nexport const GetBookByGenre = async (genreID) => {\n  const response = await fetch(`http://localhost:5000/api/book/genre/${genreID}`);\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n\n  const books = await response.json();\n\n  if (!booksByGenre[genreID]) {\n    booksByGenre[genreID] = [];\n  }\n\n  books.forEach(book => {\n    booksByGenre[genreID].push(book);\n  });\n\n  console.log(booksByGenre);\n};\n\n/*  All Commented Below is for fetching books from Google API\n\nconst getRandomPrice = () => {\n  const prices = [19.99, 24.99, 29.99, 34.99, 39.99];\n  const randomIndex = Math.floor(Math.random() * prices.length);\n  return prices[randomIndex];\n};\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nexport const fetchAllGenres = async () => {\n  for (const genre of allGenres) {\n    await fetchBooksByGenre(genre, 64);\n    await delay(200);\n  }\n  console.log(booksByGenre);\n};\n\nconst cleanBookData = (book, matchedGenres) => {\n  const genreid = genreIDs.find(g => g.genre === matchedGenres[0])?.id ?? null;\n  count++;\n\n  return {\n    genreid: typeof genreid === \"number\" ? genreid : null,\n    title: book?.title ?? \"Unavailable\",\n    subtitle: book?.subtitle ?? null,\n    authors: Array.isArray(book?.authors) \n      ? (book.authors[0] ?? \"Unavailable\") \n      : (book?.authors ?? \"Unavailable\"),\n    publisher: book?.publisher ?? null,\n    description: book?.description ?? null,\n    pageCount: typeof book?.pageCount === \"number\" ? book.pageCount : null,\n    categories: Array.isArray(matchedGenres) \n      ? (matchedGenres[0] ?? null) \n      : (matchedGenres ?? null),\n    rating: typeof book?.averageRating === \"number\" ? book.averageRating : null,\n    maturityRating: book?.maturityRating ?? null,\n    image: book?.imageLinks?.thumbnail ?? null,\n    price: getRandomPrice()\n  }  \n};\n\n\nconst isDuplicateBook = (book, genre) => {\n  return booksByGenre[genre]?.some(existingBook => existingBook.title === book.title) ?? false;\n};\n\n\nexport const fetchBooksByGenre = async (genre, batchSize) => {\n  let booksFetched = 0;\n  let startIndex = 0;\n\n  \n  while (booksFetched < batchSize) {\n    const remainingBooks = batchSize - booksFetched;\n    const currentBatchSize = Math.min(remainingBooks, 40);\n\n    try {\n      const response = await fetch(\n        `https://www.googleapis.com/books/v1/volumes?q=subject:${genre}&maxResults=${currentBatchSize}&startIndex=${startIndex}`\n      );\n\n      const data = await response.json();\n\n      if (!data.items || data.items.length === 0) break;\n\n      for (const item of data.items) {\n        const info = item.volumeInfo;\n        if (!info || !info.imageLinks?.thumbnail) continue;\n\n        const forcedGenre = [genre];\n        const cleanedBook = cleanBookData(info, forcedGenre);\n\n        if (!booksByGenre[genre]) {\n          booksByGenre[genre] = [];\n        }\n\n        if (!isDuplicateBook(cleanedBook, genre)) {\n          booksByGenre[genre].push(cleanedBook);\n          booksFetched++;\n        }\n\n        if (booksFetched >= batchSize) break; \n      }\n\n      startIndex += currentBatchSize;\n    } catch (error) {\n      console.error(`Error fetching books for genre \"${genre}\":`, error);\n      break;\n    }\n  }\n  await delay(500);\n  console.log(booksByGenre)\n  \n  return booksByGenre;\n};\n*/\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}